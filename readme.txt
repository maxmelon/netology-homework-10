Дмитрий,

Не смог внести изменения в работу после первоначальной отправки в ЛК Нетологии, поэтому пишу здесь.

Посчитал разумным, следуя логике первого задания, здесь тоже разделить первую и вторую части.

Для первой:
Ссылка на GitHub: https://github.com/maxmelon/netology-homework-10-1
Ссылка на хостинг нетологии: http://university.netology.ru/u/geynbihner/netology-homework-10-1/index.php

Для второй:
Ссылка на GitHub: https://github.com/maxmelon/netology-homework-10-2
Ссылка на хостинг нетологии: http://university.netology.ru/u/geynbihner/netology-homework-10-2/index.php

Ответы на вопросы:
1. Распишите своё понимание полиморфизма и наследования. Своими словами. Представьте, что вас спрашивают на собеседованиии.
Наследование – это один из основных принципов объектно-ориентированного программирования, заключающийся в передаче свойств и методов от одного класса элементов другому по принципу «от общего к частному».
Полиморфизм – это один из основных принципов объектно-ориентированного программирования, заключающийся в возможности изменения методов и свойств, унаследованных от старшей (общей) структуры в рамках относительно более младшей структуры.

2. Своими словами распишите отличие интерфейсов и абстрактных классов. В чем отличие? Когда лучше использовать одно, когда другое?
Интерфейс класса – это те операции (публичные методы), посредством которых с классом взаимодействует внешняя программа.
Абстрактный класс – это класс, который имеет хотя бы один абстрактный метод, то есть метод, не имеющий реализации в рамках родительского класса, но который должен быть обязательно реализован в классах-наследниках.
Интерфейс класса используется в том случае, когда необходимо установить, к каким методам класса можно будет обращаться извне. Все из определенных методов должны будут присутствовать в имплементирующем данный интерфейс классе. Однако в рамках интерфейса не допускается установление какой-либо реализации данных методов.
Создание абстрактного класса с абстрактными методами обосновано в том случае, когда на этапе родительской структуры необходимо жестко задать, какие из методов, которые не могут быть установлены сразу в родительском классе, должны быть обязательно реализованы в наследующем от него дочернем классе.
